"""
Python implementation of the seqc waveform functions

based on https://docs.zhinst.com/hdawg_user_manual/functional_description/awg.html

Currently we have implemented:
    - zeros
    - ones
    - sine
    - cosine
    - sinc
    - ramp
    - sawtooth
    - triangle
    - gauss
    - drag
    - blackman
    - hamming
    - hann
    - rect
    - chirp
    - rrc

Currently we have not implemented:
    - marker
    - rand -> white noise
    - randGauss -> white noise
    Note: rand and randGauss have same description are they the same function?
    - randomUniform -> uniform distribution of noise
    - lfsrGaloisMarker
These functions can be implemented upon request.

"""
# todo verify behaviour is correct by comparing to waveforms generated by zi instr

import warnings

import numpy as np
from scipy import signal

__all__ = [
    "zeros",
    "placeholder",
    "ones",
    "sine",
    "cosine",
    "sinc",
    "ramp",
    "sawtooth",
    "triangle",
    "gauss",
    "drag",
    "blackman",
    "hamming",
    "hann",
    "rect",
    "chirp",
    "rrc",
]


def zeros(samples: int) -> np.ndarray:
    """
    Constant amplitude of 0 over the defined number of samples.

    Args:
        samples (int): Number of samples in the waveform

    Returns:
        np.ndarray: 1d numpy array with length 'samples' and all values as 1
    """
    return np.zeros(int(samples))


def placeholder(samples: int) -> np.ndarray:
    """
    Placeholder function to be used for functions that are not yet implemented.

    Args:
        samples (int): Number of samples in the waveform

    Returns:
        np.ndarray: 1d numpy array with length 'samples' and all values as 0
    """
    return np.zeros(int(samples))


def ones(samples: int) -> np.ndarray:
    """
    Constant amplitude of 1 over the defined number of samples.

    Args:
        samples (int): Number of samples in the waveform

    Returns:
        np.ndarray: 1d numpy array with length 'samples' and all values as 1
    """
    return np.ones(int(samples))


def sine(
    samples: int,
    amplitue: float,
    phase_offset: float,
    n_periods: int,
) -> np.ndarray:
    """
    Sine function with arbitrary amplitude, phase offset in radians,
    number of periods and number of samples.

    Args:
        samples (int): Number of samples in the waveform
        amplitue (float):  Amplitude of the signal.
        phase_offset (float): Phase offset of the signal in radians
        n_periods (int): Number of Periods within the defined number of samples

    Note:
        in the seqc function the amplitude component is optional with default value 1.0

    Returns:
        np.ndarray: resulting waveform
    """
    return amplitue * np.sin(
        2 * np.pi * n_periods * np.arange(samples) / samples + phase_offset
    )


def cosine(
    samples: int,
    amplitue: float,
    phase_offset: float,
    n_periods: int,
) -> np.ndarray:
    """
    Cosine function with arbitrary amplitude, phase offset in radians,
    number of periods and number of samples.

    Args:
        samples (int): Number of samples in the waveform
        amplitue (float):  Amplitude of the signal.
        phase_offset (float): Phase offset of the signal in radians
        n_periods (int): Number of Periods within the defined number of samples

    Note:
        in the seqc function the amplitude component is optional with default value 1.0

    Returns:
        np.ndarray: resulting waveform
    """
    return amplitue * np.cos(
        2 * np.pi * n_periods * np.arange(samples) / samples + phase_offset
    )


def sinc(samples: int, amplitude: float, position: int, beta: float) -> np.ndarray:
    """
    Normalized sinc function with control of peak position, amplitude, width (beta)
    and number of samples.

    Args:
        samples (int):  Number of samples in the waveform
        amplitude (float): Amplitude of the signal (optional)
        position (int): Peak position of the function
        beta (float): Width of the function

    Note:
        in the seqc function the amplitude component is optional with default value 1.0


    Returns:
        np.ndarray: resulting waveform
    """
    return amplitude * np.sinc(2 * beta * (np.arange(samples) - position) / samples)


def ramp(samples: int, start_level: float, end_level: float) -> np.ndarray:
    """
    Linear ramp from the start level to the end level over the number of samples.

    Args:
        samples (int): Number of samples in the waveform
        start_level (float): level at the first sample of the waveform
        end_level (float): level at the last sample of the waveform

    Returns:
        np.ndarray: resulting waveform
    """
    return start_level + np.arange(samples) * (end_level - start_level) / (samples - 1)


def sawtooth(
    samples: int, amplitude: float, phase_offset: float, n_periods: int
) -> np.ndarray:
    """
    Sawtooth function with arbitrary amplitude, phase in radians and number of periods.

    Args:
        samples (int): Number of samples in the waveform
        amplitude (float): Amplitude of the signal
        phase_offset (float): Phase offset of the signal in radians
        n_periods (int): Number of Periods within the defined number of samples

    Returns:
        np.ndarray: resulting waveform
    """
    return amplitude * signal.sawtooth(
        2 * np.pi * n_periods * np.arange(samples) / samples + phase_offset
    )


def triangle(
    samples: int, amplitude: float, phase_offset: float, n_periods: int
) -> np.ndarray:
    """
    Triangle function with arbitrary amplitude, phase in radians and number of periods.

    Args:
        samples (int): Number of samples in the waveform
        amplitude (float): Amplitude of the signal
        phase_offset (float): Phase offset of the signal in radians
        n_periods (int): Number of Periods within the defined number of samples

    Returns:
        np.ndarray: resulting waveform
    """
    return amplitude * signal.sawtooth(
        2 * np.pi * n_periods * np.arange(samples) / samples + phase_offset, width=0.5
    )


def gauss(samples: int, amplitude: float, position: int, width: float) -> np.ndarray:
    """
    Gaussian pulse with arbitrary amplitude, position, width and number of samples.

    Args:
        samples (int):  Number of samples in the waveform
        amplitude (float): Amplitude of the signal
        position (int): Peak position of the function
        width (float): Width of the pulse

    Note:
        in the seqc function the amplitude component is optional with default value 1.0

    Returns:
        np.ndarray: resulting waveform
    """
    values = (np.arange(samples) - position) / width
    return amplitude * np.exp(-np.power(values, 2) / 2)


def drag(samples: int, amplitude: float, position: int, width: float) -> np.ndarray:
    """
    Derivative of Gaussian pulse with arbitrary amplitude, position, width and
    number of samples, normalized to a maximum amplitude of 1.

    Args:
        samples (int):  Number of samples in the waveform
        amplitude (float): Amplitude of the signal
        position (int): Peak position of the function
        width (float): Width of the pulse

    Note:
        in the seqc function the amplitude component is optional with default value 1.0

    Returns:
        np.ndarray: resulting waveform
    """
    values = (np.arange(samples) - position) / width
    return amplitude * (-values) * np.exp(-np.power(values, 2) / 2)


def blackman(samples: int, amplitude: float, alpha: float) -> np.ndarray:
    """
    Blackman window function with arbitrary amplitude, alpha parameter
    and number of samples.

    Args:
        samples (int): Number of samples in the waveform
        amplitude (float): Amplitude of the signal
        alpha (float): Width of the function

    Note:
        in the seqc function the amplitude component is optional with default value 1.0

    Returns:
        np.ndarray: resulting waveform
    """
    a_0 = (1 - alpha) * 0.5
    a_1 = 0.5
    a_2 = alpha * 0.5
    values = 2 * np.pi * np.arange(samples) / (samples - 1)
    return amplitude * (a_0 - a_1 * np.cos(values) + a_2 * np.cos(2 * values))


def hamming(samples: int, amplitude: float) -> np.ndarray:
    """
    Hamming window function with arbitrary amplitude and number of samples.

    Args:
        samples (int): Number of samples in the waveform
        amplitude (float): Amplitude of the signal

    Note:
        in the seqc function the amplitude component is optional with default value 1.0

    Returns:
        np.ndarray: resulting waveform
    """
    alpha = 0.54
    beta = 0.46
    values = 2 * np.pi * np.arange(samples) / (samples - 1)
    return amplitude * (alpha - beta * np.cos(values))


def hann(samples: int, amplitude: float) -> np.ndarray:
    """
    Hann window function with arbitrary amplitude and number of samples.

    Args:
        samples (int): Number of samples in the waveform
        amplitude (float): Amplitude of the signal

    Note:
        in the seqc function the amplitude component is optional with default value 1.0

    Returns:
        np.ndarray: resulting waveform
    """
    values = 2 * np.pi * np.arange(samples) / (samples - 1)
    return amplitude * (1 - np.cos(values)) * 0.5


def rect(samples: int, amplitude: float) -> np.ndarray:
    """
    Rectangle function, constants amplitude over the defined number of samples.

    Args:
        samples (int): Number of samples in the waveform
        amplitude (float): Amplitude of the signal

    Returns:
        np.ndarray: resulting waveform
    """
    return amplitude * np.ones(samples)


def chirp(
    samples: int,
    amplitude: float,
    start_freq: float,
    stop_freq: float,
    phase: float = 0.0,
) -> np.ndarray:
    """
    Frequency chirp function with arbitrary amplitude, start and stop frequency,
    initial phase in radians and number of samples.
    Start and stop frequency are expressed in units of the AWG Sampling Rate.
    The amplitude can only be defined if the initial phase is defined as well.

    Args:
        samples (int): Number of samples in the waveform
        amplitude (float): Amplitude of the signal
        start_freq (float): Start frequency of the signal
        stop_freq (float): Stop Frequency of the signal
        phase (float, optional): Initial phase of the signal. Defaults to 0.0.

    Note:
        in the seqc function the amplitude component is optional with default value 1.0

    Returns:
        np.ndarray: resulting waveform
    """
    freq_values = start_freq + np.arange(samples) * (stop_freq - start_freq) / (
        samples - 1
    )
    time_values = np.arange(samples) / samples
    return amplitude * np.sin(2 * np.pi * freq_values * time_values + phase)


def rrc(
    samples: int, amplitude: float, position: int, beta: float, width: float
) -> np.ndarray:
    """
    Root raised cosine function with arbitrary amplitude, position,
    roll-off factor (beta) and width and number of samples.

    Args:
        samples (int): Number of samples in the waveform
        amplitude (float): Amplitude of the signal
        position (int): Center point position of the pulse
        beta (float): Roll-off factor
        width (float): Width of the pulse

    Returns:
        np.ndarray: Resulting waveform
    """

    def _special_value():
        """
        For case where sample index overlaps with position +/- samples/(8*beta*width)
        see (note width = 2/Ts):
        https://en.wikipedia.org/wiki/Root-raised-cosine_filter
        """
        val0 = 2 / np.pi
        val1 = np.pi / (4 * beta)
        val2 = np.sqrt(2) * width
        return beta * ((1 + val0) * np.sin(val1) + (1 - val0) * np.cos(val1)) / val2

    indicies = np.arange(samples)
    values = 2 * width * (indicies - position) / samples
    with warnings.catch_warnings():
        # Due to local discontinuties this calculations raises a runtime warning.
        # We deal with these discontinuties below so we supress the warning here.
        warnings.simplefilter("ignore")
        wfm = (
            np.sin(values * np.pi * (1 - beta))
            + 4 * values * beta * np.cos(values * np.pi * (1 + beta))
        ) / (values * np.pi * (1 - np.power(4 * values * beta, 2)))
    # dealing with local discontinuties
    if position in indicies:
        wfm[position] = (1 + beta * (4 / np.pi - 1)) * width
    if position - samples / (8 * beta * width) in indicies:
        wfm[int(position - samples / (8 * beta * width))] = _special_value()
    if position + samples / (8 * beta * width) in indicies:
        wfm[int(position + samples / (8 * beta * width))] = _special_value()
    return amplitude * wfm
